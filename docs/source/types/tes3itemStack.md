# tes3itemStack
<div class="search_terms" style="display: none">tes3itemstack, itemstack</div>

<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->

Item stack represents all copies of an item with the same id inside an inventory. This complex container holds a relationship between an item, and zero or more associated item datas. The `itemStack.variables` is a list of different itemData for each item in the stack, not a single itemData. Not every item in the stack needs to have associated itemData. The game adds itemData to items on equipping with the exception of thrown weapons and ammo.

For example, you might have five journeyman lockpicks:

- 3 new ones (25 uses)
- 1 with 23 uses
- 1 with 18 uses

In this example, all of these lockpicks are represented by a single tes3itemStack object. The `stack.count` is 5. The `#stack.variables` is 2, since there are only 2 used lockpicks, with each having different itemData. The count of new lockpicks is equal to `stack.count - #stack.variables`.


??? example "Example: In the iterItems() function we can see that the an item stack can consist of items with itemData and items without it"

	```lua
	
	--- This is a generic iterator function that is used
	--- to loop over all the items in an inventory
	---@param actor tes3actor
	---@return fun(): tes3item, integer, tes3itemData|nil
	local function iterItems(actor)
		local function iterator()
			for _, stack in pairs(actor.inventory) do
				local item = stack.object
				-- Skip uncarryable lights. They are hidden from the interface. A MWSE mod
				-- could make the player glow from transferring such lights, which the player
				-- can't remove. Some creatures like atronaches have uncarryable lights
				-- in their inventory to make them glow that are not supposed to be looted.
				if item.canCarry == false then
					goto continue
				end
	
				-- Account for restocking items,
				-- since their count is negative.
				local count = math.abs(stack.count)
	
				-- First yield stacks with custom data
				for _, data in pairs(stack.variables or {}) do
					coroutine.yield(item, data.count, data)
					count = count - data.count
				end
	
				-- Then yield all the remaining copies
				if count > 0 then
					coroutine.yield(item, count)
				end
	
				:: continue ::
			end
		end
		return coroutine.wrap(iterator)
	end
	
	local player = tes3.player.object --[[@as tes3actor]]
	for item, count, itemData in iterItems(player) do
		debug.log(item)
		debug.log(count)
		debug.log(itemData)
	end

	```

## Properties

### `count`
<div class="search_terms" style="display: none">count</div>

The total number of items in the stack.

**Returns**:

* `result` (integer)

***

### `object`
<div class="search_terms" style="display: none">object</div>

*Read-only*. The core game object that the stack represents. Leveled items can only appear in inventories of base actors (tes3container, tes3creature, tes3npc) while corresponding actor instances always have leveled lists resolved.

**Returns**:

* `result` ([tes3item](../types/tes3item.md), [tes3leveledItem](../types/tes3leveledItem.md))

***

### `variables`
<div class="search_terms" style="display: none">variables</div>

A collection of variables that are associated with the stack's object, or nil if there aren't any.

**Returns**:

* `result` ([tes3itemData](../types/tes3itemData.md)[], nil)

